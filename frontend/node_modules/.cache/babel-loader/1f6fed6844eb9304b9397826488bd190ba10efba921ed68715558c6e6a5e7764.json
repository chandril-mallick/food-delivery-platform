{"ast":null,"code":"// src/services/supabaseAuthService.js\n// Lightweight phone OTP service using Supabase Auth\n// Usage:\n//   import supabaseAuth from './supabaseAuthService'\n//   const { success, error } = await supabaseAuth.sendOTP('+919876543210')\n//   const { success, user, session, error } = await supabaseAuth.verifyOTP('+919876543210', '123456')\n\nimport { supabase } from '../lib/supabaseClient';\nimport { db, auth as firebaseAuth } from '../firebase/config';\nlet _anonAuthStarted = false;\nconst ensureFirebaseAuth = async () => {\n  if (_anonAuthStarted) return;\n  _anonAuthStarted = true;\n  try {\n    const {\n      signInAnonymously,\n      onAuthStateChanged\n    } = await import('firebase/auth');\n    // If already signed in, skip\n    if (firebaseAuth.currentUser) return;\n    await signInAnonymously(firebaseAuth);\n    // Optionally wait for state\n    await new Promise(resolve => {\n      const unsub = onAuthStateChanged(firebaseAuth, () => {\n        unsub();\n        resolve();\n      });\n    });\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.warn('[Supabase] Anonymous Firebase auth failed (Firestore may require auth):', e === null || e === void 0 ? void 0 : e.message);\n  }\n};\nconst normalizePhone = phone => {\n  const digitsOnly = String(phone || '').replace(/\\D/g, '');\n  if (!digitsOnly) return '';\n  if (digitsOnly.startsWith('91')) return `+${digitsOnly}`; // already has country code\n  if (String(phone).startsWith('+')) return `+${digitsOnly}`;\n  return `+91${digitsOnly}`; // default India\n};\nclass SupabaseAuthService {\n  // Send OTP via SMS\n  async sendOTP(phone) {\n    const formatted = normalizePhone(phone);\n    if (!formatted) {\n      return {\n        success: false,\n        error: 'Please enter a valid phone number'\n      };\n    }\n\n    // Helpful debug log in development\n    if (process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line no-console\n      console.debug('[Supabase] Sending OTP to', formatted);\n    }\n    const options = {\n      // 60s default. You can raise on server side in Supabase Auth settings.\n      shouldCreateUser: true\n    };\n    // Only force SMS channel if explicitly enabled via env and provider is configured\n    if (process.env.REACT_APP_SUPABASE_USE_SMS_CHANNEL === 'true') {\n      options.channel = 'sms';\n    }\n    const {\n      data,\n      error\n    } = await supabase.auth.signInWithOtp({\n      phone: formatted,\n      options\n    });\n    if (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.error('[Supabase] signInWithOtp error', {\n          status: error.status,\n          message: error.message,\n          phone: formatted\n        });\n      }\n      // Provide actionable guidance for common 400 issues\n      let message = error.message || 'Failed to send OTP';\n      if (String(error.message).toLowerCase().includes('phone')) {\n        message = 'Invalid phone number. Use full number with country code, e.g. +919733960909';\n      }\n      // When using Test Phone Numbers in Supabase, ensure mapping includes country code without plus, e.g. 919733960909=123456\n      if (error.status === 400) {\n        message += ' • Check Supabase Auth: Providers → Phone is enabled and SMS provider or Test Phone Numbers are configured (use 919...=123456 for India)';\n      }\n      if (String(error.message).toLowerCase().includes('unsupported phone provider')) {\n        message = 'Unsupported phone provider. Either configure an SMS provider (Twilio) in Supabase Auth or remove forcing the SMS channel. You can enable SMS channel by setting REACT_APP_SUPABASE_USE_SMS_CHANNEL=true (requires dev server restart). For testing without Twilio, keep it false and use Test Phone Numbers.';\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        message += ` • Sent phone: ${formatted}`;\n      }\n      return {\n        success: false,\n        error: message\n      };\n    }\n    return {\n      success: true,\n      data\n    };\n  }\n\n  // Verify the OTP and sign in\n  async verifyOTP(phone, token, additionalData = {}) {\n    const formatted = normalizePhone(phone);\n    if (!formatted || !token) {\n      return {\n        success: false,\n        error: 'Phone and OTP are required'\n      };\n    }\n    const {\n      data,\n      error\n    } = await supabase.auth.verifyOtp({\n      phone: formatted,\n      token,\n      type: 'sms'\n    });\n    if (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n    const {\n      user,\n      session\n    } = data || {};\n\n    // Optionally create/update a profile in Firestore to match your existing schema\n    if (db && user !== null && user !== void 0 && user.id) {\n      try {\n        await ensureFirebaseAuth();\n        // dynamic import to avoid hard dependency when Firebase isn't present\n        const {\n          doc,\n          getDoc,\n          setDoc,\n          updateDoc\n        } = await import('firebase/firestore');\n        const userRef = doc(db, 'users', user.id);\n        const snap = await getDoc(userRef);\n        const payload = {\n          uid: user.id,\n          phoneNumber: user.phone,\n          lastLogin: new Date(),\n          updatedAt: new Date(),\n          // Tie this Supabase user doc to the current Firebase (anonymous) auth uid for Firestore rules\n          authUid: firebaseAuth.currentUser ? firebaseAuth.currentUser.uid : undefined,\n          ...additionalData\n        };\n        if (!snap.exists()) {\n          await setDoc(userRef, {\n            ...payload,\n            createdAt: new Date(),\n            addresses: [],\n            orderHistory: []\n          });\n        } else {\n          await updateDoc(userRef, payload);\n        }\n      } catch (profileErr) {\n        // eslint-disable-next-line no-console\n        console.warn('[Supabase] Skipped Firestore profile sync:', profileErr === null || profileErr === void 0 ? void 0 : profileErr.message);\n      }\n    }\n    return {\n      success: true,\n      user,\n      session\n    };\n  }\n\n  // Get current Supabase session/user\n  async getSession() {\n    const {\n      data\n    } = await supabase.auth.getSession();\n    return (data === null || data === void 0 ? void 0 : data.session) || null;\n  }\n  async getUser() {\n    const {\n      data\n    } = await supabase.auth.getUser();\n    return (data === null || data === void 0 ? void 0 : data.user) || null;\n  }\n  async signOut() {\n    const {\n      error\n    } = await supabase.auth.signOut();\n    if (error) return {\n      success: false,\n      error: error.message\n    };\n    return {\n      success: true\n    };\n  }\n\n  // Auth state listener compatible with Firebase\n  onAuthStateChanged(callback) {\n    // Get initial session\n    this.getUser().then(user => {\n      callback(user);\n    });\n\n    // Listen for auth changes\n    const {\n      data: {\n        subscription\n      }\n    } = supabase.auth.onAuthStateChange((event, session) => {\n      callback((session === null || session === void 0 ? void 0 : session.user) || null);\n    });\n\n    // Return unsubscribe function\n    return () => {\n      subscription.unsubscribe();\n    };\n  }\n\n  // User profile management methods (compatible with Firebase structure)\n  async getUserProfile(userId) {\n    if (!db) {\n      var _user$user_metadata;\n      // If no Firebase, return basic profile from Supabase user\n      const user = await this.getUser();\n      return user ? {\n        uid: user.id,\n        phoneNumber: user.phone,\n        displayName: ((_user$user_metadata = user.user_metadata) === null || _user$user_metadata === void 0 ? void 0 : _user$user_metadata.displayName) || '',\n        addresses: [],\n        orderHistory: []\n      } : null;\n    }\n    try {\n      // Ensure we are signed into Firebase (anonymous) before reading\n      await ensureFirebaseAuth();\n      const {\n        doc,\n        getDoc\n      } = await import('firebase/firestore');\n      const userRef = doc(db, 'users', userId);\n      const snap = await getDoc(userRef);\n      return snap.exists() ? snap.data() : null;\n    } catch (error) {\n      console.error('Error getting user profile:', error);\n      return null;\n    }\n  }\n  async updateUserProfile(userId, profileData) {\n    if (!db) {\n      return {\n        success: false,\n        error: 'Firestore not available'\n      };\n    }\n    try {\n      await ensureFirebaseAuth();\n      const {\n        doc,\n        setDoc\n      } = await import('firebase/firestore');\n      const userRef = doc(db, 'users', userId);\n      const payload = {\n        ...profileData,\n        updatedAt: new Date(),\n        // Ensure authUid present when creating via merge (satisfies create rule)\n        authUid: firebaseAuth.currentUser ? firebaseAuth.currentUser.uid : undefined\n      };\n      await setDoc(userRef, payload, {\n        merge: true\n      });\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error updating user profile:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n  async addAddress(userId, address) {\n    if (!db) {\n      return {\n        success: false,\n        error: 'Firestore not available'\n      };\n    }\n    try {\n      await ensureFirebaseAuth();\n      const {\n        doc,\n        getDoc,\n        setDoc,\n        updateDoc,\n        arrayUnion\n      } = await import('firebase/firestore');\n      const userRef = doc(db, 'users', userId);\n      const snap = await getDoc(userRef);\n      if (!snap.exists()) {\n        await setDoc(userRef, {\n          addresses: [address],\n          updatedAt: new Date(),\n          createdAt: new Date(),\n          authUid: firebaseAuth.currentUser ? firebaseAuth.currentUser.uid : undefined\n        }, {\n          merge: true\n        });\n      } else {\n        await updateDoc(userRef, {\n          addresses: arrayUnion(address),\n          updatedAt: new Date()\n        });\n      }\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error adding address:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Alias for signOut to match Firebase interface\n  async logout() {\n    return await this.signOut();\n  }\n\n  // Cleanup method (no-op for Supabase)\n  cleanup() {\n    // No cleanup needed for Supabase\n  }\n}\nconst supabaseAuth = new SupabaseAuthService();\nexport default supabaseAuth;","map":{"version":3,"names":["supabase","db","auth","firebaseAuth","_anonAuthStarted","ensureFirebaseAuth","signInAnonymously","onAuthStateChanged","currentUser","Promise","resolve","unsub","e","console","warn","message","normalizePhone","phone","digitsOnly","String","replace","startsWith","SupabaseAuthService","sendOTP","formatted","success","error","process","env","NODE_ENV","debug","options","shouldCreateUser","REACT_APP_SUPABASE_USE_SMS_CHANNEL","channel","data","signInWithOtp","status","toLowerCase","includes","verifyOTP","token","additionalData","verifyOtp","type","user","session","id","doc","getDoc","setDoc","updateDoc","userRef","snap","payload","uid","phoneNumber","lastLogin","Date","updatedAt","authUid","undefined","exists","createdAt","addresses","orderHistory","profileErr","getSession","getUser","signOut","callback","then","subscription","onAuthStateChange","event","unsubscribe","getUserProfile","userId","_user$user_metadata","displayName","user_metadata","updateUserProfile","profileData","merge","addAddress","address","arrayUnion","logout","cleanup","supabaseAuth"],"sources":["/Users/chandrilmallick/Downloads/web-projects/dabba-app/frontend/src/services/supabaseAuthService.js"],"sourcesContent":["// src/services/supabaseAuthService.js\n// Lightweight phone OTP service using Supabase Auth\n// Usage:\n//   import supabaseAuth from './supabaseAuthService'\n//   const { success, error } = await supabaseAuth.sendOTP('+919876543210')\n//   const { success, user, session, error } = await supabaseAuth.verifyOTP('+919876543210', '123456')\n\nimport { supabase } from '../lib/supabaseClient'\nimport { db, auth as firebaseAuth } from '../firebase/config'\n\nlet _anonAuthStarted = false\nconst ensureFirebaseAuth = async () => {\n  if (_anonAuthStarted) return\n  _anonAuthStarted = true\n  try {\n    const { signInAnonymously, onAuthStateChanged } = await import('firebase/auth')\n    // If already signed in, skip\n    if (firebaseAuth.currentUser) return\n    await signInAnonymously(firebaseAuth)\n    // Optionally wait for state\n    await new Promise((resolve) => {\n      const unsub = onAuthStateChanged(firebaseAuth, () => {\n        unsub()\n        resolve()\n      })\n    })\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.warn('[Supabase] Anonymous Firebase auth failed (Firestore may require auth):', e?.message)\n  }\n}\n\nconst normalizePhone = (phone) => {\n  const digitsOnly = String(phone || '').replace(/\\D/g, '')\n  if (!digitsOnly) return ''\n\n  if (digitsOnly.startsWith('91')) return `+${digitsOnly}` // already has country code\n  if (String(phone).startsWith('+')) return `+${digitsOnly}`\n  return `+91${digitsOnly}` // default India\n}\n\nclass SupabaseAuthService {\n  // Send OTP via SMS\n  async sendOTP(phone) {\n    const formatted = normalizePhone(phone)\n    if (!formatted) {\n      return { success: false, error: 'Please enter a valid phone number' }\n    }\n\n    // Helpful debug log in development\n    if (process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line no-console\n      console.debug('[Supabase] Sending OTP to', formatted)\n    }\n\n    const options = {\n      // 60s default. You can raise on server side in Supabase Auth settings.\n      shouldCreateUser: true\n    }\n    // Only force SMS channel if explicitly enabled via env and provider is configured\n    if (process.env.REACT_APP_SUPABASE_USE_SMS_CHANNEL === 'true') {\n      options.channel = 'sms'\n    }\n\n    const { data, error } = await supabase.auth.signInWithOtp({\n      phone: formatted,\n      options\n    })\n\n    if (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.error('[Supabase] signInWithOtp error', { status: error.status, message: error.message, phone: formatted })\n      }\n      // Provide actionable guidance for common 400 issues\n      let message = error.message || 'Failed to send OTP'\n      if (String(error.message).toLowerCase().includes('phone')) {\n        message = 'Invalid phone number. Use full number with country code, e.g. +919733960909'\n      }\n      // When using Test Phone Numbers in Supabase, ensure mapping includes country code without plus, e.g. 919733960909=123456\n      if (error.status === 400) {\n        message += ' • Check Supabase Auth: Providers → Phone is enabled and SMS provider or Test Phone Numbers are configured (use 919...=123456 for India)'\n      }\n      if (String(error.message).toLowerCase().includes('unsupported phone provider')) {\n        message = 'Unsupported phone provider. Either configure an SMS provider (Twilio) in Supabase Auth or remove forcing the SMS channel. You can enable SMS channel by setting REACT_APP_SUPABASE_USE_SMS_CHANNEL=true (requires dev server restart). For testing without Twilio, keep it false and use Test Phone Numbers.'\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        message += ` • Sent phone: ${formatted}`\n      }\n      return { success: false, error: message }\n    }\n\n    return { success: true, data }\n  }\n\n  // Verify the OTP and sign in\n  async verifyOTP(phone, token, additionalData = {}) {\n    const formatted = normalizePhone(phone)\n    if (!formatted || !token) {\n      return { success: false, error: 'Phone and OTP are required' }\n    }\n\n    const { data, error } = await supabase.auth.verifyOtp({\n      phone: formatted,\n      token,\n      type: 'sms'\n    })\n\n    if (error) {\n      return { success: false, error: error.message }\n    }\n\n    const { user, session } = data || {}\n\n    // Optionally create/update a profile in Firestore to match your existing schema\n    if (db && user?.id) {\n      try {\n        await ensureFirebaseAuth()\n        // dynamic import to avoid hard dependency when Firebase isn't present\n        const { doc, getDoc, setDoc, updateDoc } = await import('firebase/firestore')\n        const userRef = doc(db, 'users', user.id)\n        const snap = await getDoc(userRef)\n        const payload = {\n          uid: user.id,\n          phoneNumber: user.phone,\n          lastLogin: new Date(),\n          updatedAt: new Date(),\n          // Tie this Supabase user doc to the current Firebase (anonymous) auth uid for Firestore rules\n          authUid: firebaseAuth.currentUser ? firebaseAuth.currentUser.uid : undefined,\n          ...additionalData\n        }\n        if (!snap.exists()) {\n          await setDoc(userRef, { ...payload, createdAt: new Date(), addresses: [], orderHistory: [] })\n        } else {\n          await updateDoc(userRef, payload)\n        }\n      } catch (profileErr) {\n        // eslint-disable-next-line no-console\n        console.warn('[Supabase] Skipped Firestore profile sync:', profileErr?.message)\n      }\n    }\n\n    return { success: true, user, session }\n  }\n\n  // Get current Supabase session/user\n  async getSession() {\n    const { data } = await supabase.auth.getSession()\n    return data?.session || null\n  }\n\n  async getUser() {\n    const { data } = await supabase.auth.getUser()\n    return data?.user || null\n  }\n\n  async signOut() {\n    const { error } = await supabase.auth.signOut()\n    if (error) return { success: false, error: error.message }\n    return { success: true }\n  }\n\n  // Auth state listener compatible with Firebase\n  onAuthStateChanged(callback) {\n    // Get initial session\n    this.getUser().then(user => {\n      callback(user);\n    });\n\n    // Listen for auth changes\n    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {\n      callback(session?.user || null);\n    });\n\n    // Return unsubscribe function\n    return () => {\n      subscription.unsubscribe();\n    };\n  }\n\n  // User profile management methods (compatible with Firebase structure)\n  async getUserProfile(userId) {\n    if (!db) {\n      // If no Firebase, return basic profile from Supabase user\n      const user = await this.getUser();\n      return user ? {\n        uid: user.id,\n        phoneNumber: user.phone,\n        displayName: user.user_metadata?.displayName || '',\n        addresses: [],\n        orderHistory: []\n      } : null;\n    }\n\n    try {\n      // Ensure we are signed into Firebase (anonymous) before reading\n      await ensureFirebaseAuth()\n      const { doc, getDoc } = await import('firebase/firestore');\n      const userRef = doc(db, 'users', userId);\n      const snap = await getDoc(userRef);\n      return snap.exists() ? snap.data() : null;\n    } catch (error) {\n      console.error('Error getting user profile:', error);\n      return null;\n    }\n  }\n\n  async updateUserProfile(userId, profileData) {\n    if (!db) {\n      return { success: false, error: 'Firestore not available' };\n    }\n\n    try {\n      await ensureFirebaseAuth()\n      const { doc, setDoc } = await import('firebase/firestore');\n      const userRef = doc(db, 'users', userId);\n      const payload = {\n        ...profileData,\n        updatedAt: new Date(),\n        // Ensure authUid present when creating via merge (satisfies create rule)\n        authUid: firebaseAuth.currentUser ? firebaseAuth.currentUser.uid : undefined\n      };\n      await setDoc(userRef, payload, { merge: true });\n      return { success: true };\n    } catch (error) {\n      console.error('Error updating user profile:', error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  async addAddress(userId, address) {\n    if (!db) {\n      return { success: false, error: 'Firestore not available' };\n    }\n\n    try {\n      await ensureFirebaseAuth()\n      const { doc, getDoc, setDoc, updateDoc, arrayUnion } = await import('firebase/firestore');\n      const userRef = doc(db, 'users', userId);\n      const snap = await getDoc(userRef);\n      if (!snap.exists()) {\n        await setDoc(\n          userRef,\n          {\n            addresses: [address],\n            updatedAt: new Date(),\n            createdAt: new Date(),\n            authUid: firebaseAuth.currentUser ? firebaseAuth.currentUser.uid : undefined\n          },\n          { merge: true }\n        );\n      } else {\n        await updateDoc(userRef, {\n          addresses: arrayUnion(address),\n          updatedAt: new Date()\n        });\n      }\n      return { success: true };\n    } catch (error) {\n      console.error('Error adding address:', error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  // Alias for signOut to match Firebase interface\n  async logout() {\n    return await this.signOut();\n  }\n\n  // Cleanup method (no-op for Supabase)\n  cleanup() {\n    // No cleanup needed for Supabase\n  }\n}\n\nconst supabaseAuth = new SupabaseAuthService()\nexport default supabaseAuth\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}